# Типы
## Простые типы
- uint8, 16, 32, 64
- int8, 16, 32, 64, int
- float32, 64
- complex64, 128
- string в двойных "" или обратные ковычки. Обрат ковычки сохраняют текст как есть.
- byte ~ uint8
- rune ~ int32. Utf8 символ - символ в одинарных ковычках
- символ в одинарных ковычках

##  Строки
- имутабельны - нельзя редактировать, не изменяемый массив байт
- Len покажет колво байт. *RunCountString* колво символов
- при итерации по строке элемент это *rune*
```
s := "пам"
for _, e := range s {
	if e == 'п' {
		fmt.Println("rune")
	}
	if e == 1087 {
		fmt.Println("rune")
	}
}
```
- при итерации индекс, это порядковый номер байта с которого начинается руна.
```
const nihongo = "日本語"
for index, runeValue := range nihongo {
	fmt.Printf("%#U starts at byte position %d\n", runeValue, index) // index - 0,3,6
}
```
- конкатенация строк `str = str + "оп"
- пакет **strings** для работы со строками: **strings.Join**, **strings.Split**, **strings.ReplaceAll**, **strings.HasPrefix**, **strings.HasSuffix**, **strings.Contais**, **strings.Count** - количество вхождений подстроки в строке

## Указатели
- Указатель - это переменная, которая содержит адрес объекта.
- \& - получить адрес переменной
- \* - разименование указателя - доступ к переменной на которую указывает указатель, также используется в объявлениях типов
```
i := 1
p := &i  // p указатель на i
k := i   // k новая переменная значение скопирована с i
*p = 2   // по адресу на который указывает p кладем значение 2

fmt.Printf("%v", i)  // 2 потому что через указатель поменяли значение i
fmt.Printf("%v", k)  // 1 потому что k самостоятельная переменная
```
- new(<тип>) - возвращает указатель на тип

## Ссылочные типы
// TODO

## Интерфейс
- пустой интерфейс `interface{}` - удовлетворяет любому типу, можно использовать когда тип не определен  или типов может быть несколько
- под капотом интерфейс это структура
```
type iface struct {
    tab  *itab  // указатель на тип переменной которая прячется за интефейсом
    data unsafe.Pointer // указатель на переменную
}
```

## Слайсы
//TODO

## Map
//TODO
- ключ значениие, порядок элементов не гарантирован
- можно в качестве ключа использовать структуру
```go
m[Skey{id: 1, name: "one"}] = 1
m[Skey{id: 1, name: "one"}] = 2
m[Skey{id: 1, name: "one"}] = 3  // будет map[{1 one}:3]
```
- удалить из мапы
```go
delete(m, k)  //  удалить элемент m[k] из карты m
```

## Каналы
//TODO
- нельзя писать в закрытй канал будет паника,
- читать можно из закрытого канала. При чтение из канала возвращается две переменные значение и ok. если все вычитали и канал закрыт то значение будет значение по умолчанию, *ok* - будет *false* okстановиться false не когда канал закрыли, а когда из него все дочитали
```go
func write(c chan int) {
	for i := 1; i < 1000; i++ {
		c <- i
	}
	close(c)
	fmt.Println("chan is closed")
}

func main() {
	var c = make(chan int, 1000)
	go write(c)

	for {
		v, ok := <-c
		fmt.Printf("v %v, ok %v.", v, ok)
		if ok == false {
			break // тут val = 0, ok - false
		}
	}
}
```
- если канал не закрыть, то можем получить дедлок, программа будет ждать новых значений в канале
```go
func write(c chan int) {
	for i := 1; i < 100; i++ {
		c <- i
	}
	// close(c) // с закрытием паники не будет, без закрытия горутины повиснет в ожидание и будет паника "fatal error: all goroutines are asleep"
}

func main() {
	var c = make(chan int)
	go write(c)

	for v := range c {
		fmt.Printf("%d, ", v)
	}
}
```

## Структуры
// TODO
### Встраивание
// TODO
###  Методы структуры
- если не задумываться (к указактелю или валью этачить метод), то этачим метод к указателю на структуру
- можно вызывать метод и для валью и для указателя не зависимо к чему приэтачили метод
- если этачить метод к указателю на структуру, то изменения внутри метода видны снаружи. Если этачить к структуре, то изменения не применятся (сетер не будет работать)
- если этачим к указателю, то можно вызвать метод, даже если указатель nil
```go
type S struct {
	Name string
}

func (s *S) getName() string {
	if s == nil { // без проверки на nil, будет паника на s.Name, так как s не определен
		return "empty"
	}
	return s.Name
}

func main() {
	var s *S // nil
	fmt.Printf("get name %s", s.getName()) // get name empty
}
```

## Error
// TODO

## Time.time
// TODO

# Приведение типов
// TODO

# Переменные
## Объявление 
// TODO
## Область видимостиё
// TODO

# Управляющие конструкции
## Defer,recovery, panica
- https://go.dev/blog/defer-panic-and-recover
// TODO
- defer - функция которая вызывется после завершения метода, удобно для закрытия файла, канала и тд
- аргументы для defera вычисляются на момент объявления defer-а
```go
func withDefer() {
	x := "a"
	defer fmt.Println(x) // распечатает а
	x = "b"
}
```
- если defer-ов несколько то они будут вызываться по принципу стека (первый дефер будет последним)
## Switch
// TODO
## Циклы (for)
- есть только цикл *for*, но его можно использовать как while
- аля foreach - `for <индек>, <элемент> := range l {...`
- `for <индек> := range l {...`
- аля while - `for <true - проодолжаем цикл> {...`
- бесконечный цикл - `for {...`
- итерация по индексу `for i := 0; i < len(l); i++ {...`
- итерация по индексу несколько индексов - `for i, j := 0, 100; i < len(l); i, j = i+1, j-1 {`
## Select
// TODO


# Context
- https://go.dev/blog/context
- https://betterprogramming.pub/understanding-context-in-golang-7f574d9d94e0
- context - это первый параметр функции, который пробрасывается(явно) через весь стек вызовов, контекст используют чтобы сделать корретное завершение, (возможно в какой то ветке вызовов что то пошло не так и нету смысла продолжать в остальных горутинах), в контекст можно положить value.
- *context.WithValue(parentContext, key, value)* - вернет новый контекст в котором будет value с ключем key, в контекс можно что угодно положить, а можно и не положить (key/value в контексте не строгое требование) поэтому в коде нужно учитывать что ожидаемого ключа может и не быть в контексте, а лучше то что нам необходимо для работы функции было в параметрах функции
- ctx cancel := context.WithCancel(parentContext) - возвращается новый контекст, и метод отмены, если вызвать cancel то он закроет канал done внутри контекста, и те методы что читают этот канал поймают закрытие канала и смогут корреткно обработать отмену контекста (отмену запроса)
- WithTimeout - контекст с отменой по таймауту (через какое то время)
- WithDeadline - контекст с отменой по наступления времени.
```go
func main() {
	fmt.Println("Hello, 世界")

	ctxb := context.Background()
	go logSomething(ctxb, "Background") // не поймает Done потому что родитель для контекста с отменой
	ctxc, cancel := context.WithCancel(ctxb)
	go logSomething(ctxc, "WithCancel") // поймает Done потому что контекст с отменой
	ctxv := context.WithValue(ctxc, "val", "one")
	go logSomething(ctxv, "WithValue") // Поймает done потому что создан из контекста с отменой

	cancel()
	time.Sleep(5 * time.Second)

}

func logSomething(ctx context.Context, msg string) {
	for {
		select {
		case <-ctx.Done():
			fmt.Printf("done %s", msg)
			fmt.Println()
			return
		default:
			time.Sleep(1 * time.Second)
			fmt.Printf("wait %s", msg)
			fmt.Println()
		}
	}

}
```



# Примитивы синхронизации
### Каналы
Канал - объект связи, для общения (какие-то горутины пишут в канал какие-то читают) горутин. Через каналы можно блокировать(ждать резульатов работы других горутин) горутины
Если одна горутина записала в канал, то она не может писать следующее значение пока другая горутина не прочитает, если канал буферрезированный то можно писать без блокировки на размер буфера
```
func main() {
	c := make(chan int) // создание не буферрезированого канала

	// writer
	go func() {
		for i := 0; i < 3; i++ {
			c <- i // запись в канал
			fmt.Printf("write %d", i)
		}
		close(c) // если канал не закрыть, то будет deadlock, ридер будет вечно ждать нового значения в канале
	}()

	// reader, чтение из канала
	for i := range c {
		fmt.Printf("read %d", i)
	}
}
```
- канал ссылочный тип
- размер буфера *НЕ* буферезированного канала *0* , если писать в такой канал и нету читателся, то будет дедлок.

### RWMutex - можно давать читать, но не давать писать, 
```
var m sync.RWMutex
m.RLock() // блокировка на запись, можно читать в других горутнинах
m.RUnlock() // снимаеи блокировку
```

### Горутины
//TODO

