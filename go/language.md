# Типы
## Простые типы
- uint8, 16, 32, 64
- int8, 16, 32, 64, int
- float32, 64
- complex64, 128
- string в двойных "" или обратные ковычки. Обрат ковычки сохраняют текст как есть.
- byte ~ uint8
- rune ~ int32. Utf8 символ - символ в одинарных ковычках

##  Строки
- имутабельны - нельзя редактировать, не изменяемый массив байт
- Len покажет колво байт. *RunCountString* колво символов
- при итерации по строке элемент это *rune*
```
s := "пам"
for _, e := range s {
	if e == 'п' {
		fmt.Println("rune")
	}
	if e == 1087 {
		fmt.Println("rune")
	}
}
```
## Указатели
- Указатель - это переменная, которая содержит адрес объекта.
- \& - получить адрес переменной
- \* - разименование указателя - доступ к переменной на которую указывает указатель, также используется в объявлениях типов
```
i := 1
p := &i  // p указатель на i
k := i   // k новая переменная значение скопирована с i
*p = 2   // по адресу на который указывает p кладем значение 2

fmt.Printf("%v", i)  // 2 потому что через указатель поменяли значение i
fmt.Printf("%v", k)  // 1 потому что k самостоятельная переменная
```
- new(<тип>) - возвращает указатель на тип
## Интерфейс
- под капотом интерфейс это структура
```
type iface struct {
    tab  *itab  // указатель на тип переменной которая прячется за интефейсом
    data unsafe.Pointer // указатель на переменную
}
```

## Структуры
// TODO

# Управляющие конструкции
## Циклы (for)
- есть только цикл *for*, но его можно использовать как while
- аля foreach - `for <индек>, <элемент> := range l {...`
- `for <индек> := range l {...`
- аля while - `for <true - проодолжаем цикл> {...`
- бесконечный цикл - `for {...`
- итерация по индексу `for i := 0; i < len(l); i++ {...`
- итерация по индексу несколько индексов - `for i, j := 0, 100; i < len(l); i, j = i+1, j-1 {`
## Select

# Context
// TODO

# Приведение типов
// TODO

# Примитивы синхронизации
## Каналы
Канал - объект связи, для общения (какие-то горутины пишут в канал какие-то читают) горутин. Через каналы можно блокировать(ждать резульатов работы других горутин) горутины
Если одна горутина записала в канал, то она не может писать следующее значение пока другая горутина не прочитает, если канал буферрезированный то можно писать без блокировки на размер буфера
```
func main() {
	c := make(chan int) // создание не буферрезированого канала

	// writer
	go func() {
		for i := 0; i < 3; i++ {
			c <- i // запись в канал
			fmt.Printf("write %d", i)
		}
		close(c) // если канал не закрыть, то будет deadlock, ридер будет вечно ждать нового значения в канале
	}()

	// reader, чтение из канала
	for i := range c {
		fmt.Printf("read %d", i)
	}
}
```
- канал ссылочный тип
- размер буфера *НЕ* буферезированного канала *0* , если писать в такой канал и нету читателся, то будет дедлок.

## RWMutex - можно давать читать, но не давать писать, 
```
var m sync.RWMutex
m.RLock() // блокировка на запись, можно читать в других горутнинах
m.RUnlock() // снимаеи блокировку
```

## Горутины
## Паттерны конкурентного программирования
https://medium.com/@thejasbabu/concurrency-patterns-golang-5c5e1bcd0833
- Генераторы, Fan-In, Fan-Out, Управляющий канал и тд

